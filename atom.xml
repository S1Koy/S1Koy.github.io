<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奥印安鱼</title>
  
  
  <link href="https://s1koy.github.io/atom.xml" rel="self"/>
  
  <link href="https://s1koy.github.io/"/>
  <updated>2022-10-21T09:20:12.110Z</updated>
  <id>https://s1koy.github.io/</id>
  
  <author>
    <name>奥印安鱼</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二分总结</title>
    <link href="https://s1koy.github.io/2022/10/21/%E4%BA%8C%E5%88%86%E6%80%BB%E7%BB%93/"/>
    <id>https://s1koy.github.io/2022/10/21/%E4%BA%8C%E5%88%86%E6%80%BB%E7%BB%93/</id>
    <published>2022-10-21T09:16:52.000Z</published>
    <updated>2022-10-21T09:20:12.110Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="二分总结"><a href="#二分总结" class="headerlink" title="二分总结"></a>二分总结</h2><p>之间总结过一次，以为是最好的解释，最后看了一个知乎回答，发现有更好的解释。<a href="https://www.zhihu.com/answer/712269942">连接</a></p><h3 id="【1】寻找一个数"><a href="#【1】寻找一个数" class="headerlink" title="【1】寻找一个数"></a>【1】寻找一个数</h3><p>如$nums = [1,3,3,5,8]$，下标从$0$开始，找$3$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (r - l) / <span class="number">2</span> + l;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>为什么循环条件是$\le$，而不是$&lt;$</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为r为nums.length-1，不是nums.lenght。前者相当于是闭区间[l,r]，而后者则是开区间[l,r)，因此这里是小于等于。也就是每一次的搜索区间。</span><br></pre></td></tr></table></figure><ul><li>终止条件</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果是大于等于，那么终止条件就是l = r + 1,即[r + 1, r]，代入具体数值即[3,2]，此时区间为空。但如果是小于的话，那么终止条件就是l = r, 即[l, r]，代入具体数值即[2,2]，此时区间非空，漏掉了2，如果直接返回-1就是错误的，如果要这样写，最后要再判断一下漏掉的情况即，</span><br><span class="line">return nums[l] == target ? l : -1;</span><br></pre></td></tr></table></figure><ul><li>为什么$l=mid + 1$，$r =mid-1$?</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先明确了[搜索区间]的概念，现在是闭区间搜索，mid已经可以排除，所以分割区间为[l,mid-1]和[mid+1,r]</span><br></pre></td></tr></table></figure><p><strong>局限性</strong>：该算法无法找到最左边的$target$或者最右边的$target$。</p><h3 id="【2】寻找左侧边界"><a href="#【2】寻找左侧边界" class="headerlink" title="【2】寻找左侧边界"></a>【2】寻找左侧边界</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length;</span><br><span class="line">whiel (l &lt; r) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (r - l) / <span class="number">2</span> + l;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &gt;= target) r = mid;</span><br><span class="line">    <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br></pre></td></tr></table></figure><ul><li>为什么是$&lt;$？</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为r=nums.length,所以每次搜索区间为[l,r),而终止条件为l=r,即[l,r),此时区间为空，所以可以正确终止。</span><br></pre></td></tr></table></figure><ul><li>为什么没有返回$-1$操作，如果$nums$里不存在$target$呢？</li></ul><p><img src="/C:/Users/Admin/AppData/Roaming/Typora/typora-user-images/image-20221021150442699.png" alt="image-20221021150442699"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于上述nums，会返回1，可以解读为小于2的元素有1个。又比如nums=[2,3,5,7]，target=1，算法会返回0，即小于1的元素有0个，再比如nums不变，target=8，算法会返回4，即小于8的元素有4个。</span><br><span class="line"></span><br><span class="line">综上可以看出，函数的返回值的取值范围在[0,nums.length]，所以我们可以特判，就可以返回-1了。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (l == nums.length) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//target比所有数都大</span></span><br><span class="line"><span class="keyword">return</span> nums[l] == target ? l : -<span class="number">1</span>; <span class="comment">// target比所有数都小</span></span><br></pre></td></tr></table></figure><ul><li>为什么这里是$l=mid+1$，$r =mid$呢？</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为搜索区间是[l,r)左闭右开，所以当mid被监测后，区间被分割为[l, mid)和[mid + 1, r)</span><br></pre></td></tr></table></figure><ul><li>为什么可以搜索左边界？</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为在nums[mid]==target的时候，没有立即返回，而是缩小[搜索区间]的上界right，在区间[l,mid)中继续搜索,不断向左搜搜，达到锁定左边界</span><br></pre></td></tr></table></figure><ul><li>为什么返回$l$而不是$r$？</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">终止条件为l==r,因此返回哪一个都可以。</span><br></pre></td></tr></table></figure><h3 id="【3】寻找右侧边界"><a href="#【3】寻找右侧边界" class="headerlink" title="【3】寻找右侧边界"></a>【3】寻找右侧边界</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length;</span><br><span class="line">whiel (l &lt; r) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (r - l) / <span class="number">2</span> + l;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &lt;= target) l = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> r = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>基本上和寻找左侧边界一致，只是收缩的方向有所区别。</p><ul><li>为什么最后是$l-1$？而不是$l$？或者是$r-1$呢？</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先，终止条件是l==r,如果非要体现右边界，写成r-1也可以。</span><br></pre></td></tr></table></figure><p>​    但是为什么要$-1$呢?  主要是这个条件判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">    l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/C:/Users/Admin/AppData/Roaming/Typora/typora-user-images/image-20221021152421316.png" alt="image-20221021152421316"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对l的更新必须是l=mid+1,因为最后l一定是不等于target的，但是nums[l-1]可能是target</span><br></pre></td></tr></table></figure><ul><li>为什么没有返回$-1$操作？</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回值范围为[0,nums.length]，我们可以做特判来返回正确的结果</span><br><span class="line">if (l == 0) return -1; </span><br><span class="line">return nums[l - 1] == target ? l - 1 : -1;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法总结" scheme="https://s1koy.github.io/categories/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="二分" scheme="https://s1koy.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 940. 不同的子序列II</title>
    <link href="https://s1koy.github.io/2022/10/20/LeetCode-940-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97II/"/>
    <id>https://s1koy.github.io/2022/10/20/LeetCode-940-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97II/</id>
    <published>2022-10-20T13:07:28.000Z</published>
    <updated>2022-10-21T09:19:59.580Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>思路：想过了和上次出现有关，但是没想那么多。考虑以某个字母结尾的子序列个数，对于长度为$1$来说，只有它本身，对于长度不为$1$来说，除了它本身，它之前出现的所有以$[a-z]$结尾的子序列个数都可以累加到它身上，然后更新以该字母结尾的答案即可。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">distinctSubseqII</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] d = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        Arrays.fill(d, -<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> str[i];</span><br><span class="line">            f[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[j] != -<span class="number">1</span>) &#123;</span><br><span class="line">                    f[i] = (f[i] + f[d[j]]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            d[c - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[i] != -<span class="number">1</span>) &#123;</span><br><span class="line">                ans = (ans + f[d[i]]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里可以用g[o]表示f[d[j]],初始g数组都为0。【官方】</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">distinctSubseqII</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">int</span>[] g = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j) &#123;</span><br><span class="line">                total = (total + g[j]) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            g[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = total;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            ans = (ans + g[i]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里可以看出来每次改变的只有当前的g[0],因此我们可以对所有的子序列累加，然后根据g[i],做相应的调整。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">distinctSubseqII</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] g = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">tot</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> g[str[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            g[str[i] - <span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span> + tot;</span><br><span class="line">            tot = ((tot + g[str[i] - <span class="string">&#x27;a&#x27;</span>]) % mod - pre + mod) %mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            ans = (ans + g[i]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;思路：想过了和上次出现有关，但是没想那么多。考虑以某个字母结尾的子序列个数，对于长度为$1$来说，只有它本身，对于长度不为$1$来说，除了它本身，它之前出现的所有以$[a-z]$结尾的子序列个数都可以累加到它身上，然后更新以该字母结尾的答案即可。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://s1koy.github.io/categories/LeetCode/"/>
    
    
    <category term="DP" scheme="https://s1koy.github.io/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 第315场周赛</title>
    <link href="https://s1koy.github.io/2022/10/18/LeetCode-%E7%AC%AC315%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    <id>https://s1koy.github.io/2022/10/18/LeetCode-%E7%AC%AC315%E5%9C%BA%E5%91%A8%E8%B5%9B/</id>
    <published>2022-10-18T08:46:33.000Z</published>
    <updated>2022-10-19T06:23:51.266Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="A"><a href="#A" class="headerlink" title="A"></a><a href="https://leetcode.cn/problems/largest-positive-integer-that-exists-with-its-negative/">A</a></h2><p>思路：模拟，不过有点复杂。可以正负数都放集合里，然后判断相反数是不是在集合中即可，一次遍历。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复杂的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxK</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1010</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; cnt[-x][<span class="number">0</span>] == <span class="number">1</span>) ans = Math.max(ans, -x);</span><br><span class="line">            <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; cnt[x][<span class="number">1</span>] == <span class="number">1</span>) ans = Math.max(ans, x);</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span>) cnt[-x][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> cnt[x][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B"><a href="#B" class="headerlink" title="B"></a><a href="https://leetcode.cn/problems/count-number-of-distinct-integers-after-reverse-operations/">B</a></h2><p>思路：模拟。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countDistinctIntegers</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            set.add(x);</span><br><span class="line">            set.add(work(x));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">work</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum = sum * <span class="number">10</span> + (x % <span class="number">10</span>);</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C"><a href="#C" class="headerlink" title="C"></a><a href="https://leetcode.cn/problems/sum-of-number-and-its-reverse/">C</a></h2><p>思路：憨憨没想到，暴力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sumOfNumberAndReverse</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + work(i) == num) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">return</span> <span class="variable">num</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">work</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum = sum * <span class="number">10</span> + (x % <span class="number">10</span>);</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D"><a href="#D" class="headerlink" title="D"></a><a href="https://leetcode.cn/problems/count-subarrays-with-fixed-bounds/">D</a></h2><p>思路：不会。题目可以转化为多少子数组同时包括$minK$和$maxK$，可以将数组分为多个数字在最小最大值之间的子数组，然后再考虑对这些子数组计数。例如当前子数组为$[L,R]$计数枚举左端点$i$，然后移动右端点$j$，一旦满足同时包括最小最大值，那么贡献就是$[j,R]$这几个位置的数字个数，即$R-j+1$，因为$j$本身就是一个符合的答案。具体见代码。</p><p>当然还有其他做法，不想看了，吐！</p><p>灵神的代码，是以左边为边界，然后右边一旦出现同时包括的情况就计数，代码更加简洁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T神</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="type">int</span> minK;</span><br><span class="line">    <span class="type">int</span> maxK;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countSubarrays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> minK, <span class="type">int</span> maxK)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        <span class="built_in">this</span>.minK = minK;</span><br><span class="line">        <span class="built_in">this</span>.maxK = maxK;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">st</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; minK || nums[i] &gt; maxK) &#123;</span><br><span class="line">                ans += work(st, i - <span class="number">1</span>);</span><br><span class="line">                st = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += work(st, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">work</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> L, j = L;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minCnt</span> <span class="operator">=</span> <span class="number">0</span>, maxCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt;= R &amp;&amp; (minCnt == <span class="number">0</span> || maxCnt == <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] == minK) minCnt++;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] == maxK) maxCnt++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minCnt &gt; <span class="number">0</span> &amp;&amp; maxCnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sum += R - (j - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == minK) minCnt--;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == maxK) maxCnt--;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 灵神</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countSubarrays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> minK, <span class="type">int</span> maxK)</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, minI = -<span class="number">1</span>, maxI = -<span class="number">1</span>, i0 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">x</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="keyword">if</span> (x == minK) minI = i;</span><br><span class="line">            <span class="keyword">if</span> (x == maxK) maxI = i;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; minK || x &gt; maxK) i0 = i; <span class="comment">// 子数组不能包含 nums[i0]</span></span><br><span class="line">            ans += Math.max(Math.min(minI, maxI) - i0, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;A&quot;&gt;&lt;a href=&quot;#A&quot; class=&quot;headerlink&quot; title=&quot;A&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/largest-positive-integer-that-exists-with-its-negative/&quot;&gt;A&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;思路：模拟，不过有点复杂。可以正负数都放集合里，然后判断相反数是不是在集合中即可，一次遍历。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://s1koy.github.io/categories/LeetCode/"/>
    
    
    <category term="滑动窗口" scheme="https://s1koy.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 第314场周赛</title>
    <link href="https://s1koy.github.io/2022/10/17/LeetCode-%E7%AC%AC314%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    <id>https://s1koy.github.io/2022/10/17/LeetCode-%E7%AC%AC314%E5%9C%BA%E5%91%A8%E8%B5%9B/</id>
    <published>2022-10-17T12:59:34.000Z</published>
    <updated>2022-10-19T06:24:02.251Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="A"><a href="#A" class="headerlink" title="A"></a><a href="https://leetcode.cn/problems/the-employee-that-worked-on-the-longest-task/">A</a></h2><p>思路：比赛时看到题目就是求最大的差值，然后直接想着排序，第一个就是答案。其实可以模拟。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hardestWorker</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] logs)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> logs.length;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;logs[<span class="number">0</span>][<span class="number">1</span>], logs[<span class="number">0</span>][<span class="number">0</span>]&#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;logs[i][<span class="number">1</span>] - logs[i - <span class="number">1</span>][<span class="number">1</span>], logs[i][<span class="number">0</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(list, ((o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (o1[<span class="number">0</span>] == o2[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">1</span>] - o2[<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o2[<span class="number">0</span>] - o1[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>)[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hardestWorker</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] logs)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> logs.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> logs[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> logs[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logs[i][<span class="number">1</span>] - logs[i - <span class="number">1</span>][<span class="number">1</span>] &gt; max) &#123;</span><br><span class="line">                max = logs[i][<span class="number">1</span>] - logs[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                ans = logs[i][<span class="number">0</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (logs[i][<span class="number">1</span>] - logs[i - <span class="number">1</span>][<span class="number">1</span>] == max) &#123;</span><br><span class="line">                ans = Math.min(ans, logs[i][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B"><a href="#B" class="headerlink" title="B"></a><a href="https://leetcode.cn/problems/find-the-original-array-of-prefix-xor/">B</a></h2><p>思路：比赛时感觉第二题应该不难，但是还是上二进制了，知道初始值和异或结果，可以根据这两个数的对应二进制的数字来得到另一个数。但是可以直接利用异或的性质：</p><script type="math/tex; mode=display">A \oplus B = C \Rightarrow A \oplus C = B</script><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二进制模拟</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findArray(<span class="type">int</span>[] pref) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> pref.length;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        ans[<span class="number">0</span>] = pref[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">32</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((pref[i] &gt;&gt; j) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    x |= (pref[i - <span class="number">1</span>] &amp; (<span class="number">1</span> &lt;&lt; j));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (((pref[i - <span class="number">1</span>] &gt;&gt; j) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                        x |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 性质</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findArray(<span class="type">int</span>[] pref) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> pref.length;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        ans[<span class="number">0</span>] = pref[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans[i] = pref[i] ^ pref[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C"><a href="#C" class="headerlink" title="C"></a><a href="https://leetcode.cn/problems/using-a-robot-to-print-the-lexicographically-smallest-string/">C</a></h2><p>思路：比赛的时候考虑错了，然后就很难搞。赛后看了题解，是憨憨了。</p><p>其实是栈模拟，我们可以提前处理出字符右边是否有比当前字符更小的，有的话肯定要等着，如果没有的话，就要立马出去，才能更小，否则只会更大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">robotWithString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] f = <span class="keyword">new</span> <span class="title class_">char</span>[n + <span class="number">1</span>];</span><br><span class="line">        f[n] = <span class="string">&#x27;z&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) f[i] = str[i] &lt; f[i + <span class="number">1</span>] ? str[i] : f[i + <span class="number">1</span>];</span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            stack.offerLast(str[i]);</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peekLast() &lt;= f[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                sb.append(stack.pollLast());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D"><a href="#D" class="headerlink" title="D"></a><a href="https://leetcode.cn/problems/paths-in-matrix-whose-sum-is-divisible-by-k/">D</a></h2><p>这种取模题，一般都是计数题。只能走右或者走下，就会想到记忆化搜索或者DP，但是和以前一样，都不会试着写。</p><p>搜索：首先判越界，没有越界就看走过没有，然后看是不是结束条件，不行的话就要搜索了，这里从两个方向走，然后把回溯的结果记忆化，最后就是答案。</p><p>DP：$dp[i][j][z]$表示到位置$(i,j)$，总和取模$k$为$z$的方案数</p><p>考虑，枚举每个位置的总和模$k$的所有情况，当前的结果有了，当前格子的值有了，所以只用累加上一个位置的相应值的方案数即可，转移方程为：</p><script type="math/tex; mode=display">dp[i][j][z] = (dp[i][j][z] + dp[i - 1][j][((z - grid[i][j] \% k) + k) \% k]) \% mod, i > 0</script><script type="math/tex; mode=display">dp[i][j][z] = (dp[i][j][z] + dp[i][j - 1][((z - grid[i][j] \% k) + k) \% k]) \% mod,j>0</script><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记忆化搜索</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="type">int</span>[][] grid;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="type">int</span>[][][] dp;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfPaths</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        m = grid.length;</span><br><span class="line">        n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        <span class="built_in">this</span>.grid = grid;</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n][<span class="number">50</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                Arrays.fill(dp[i][j], -<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sum = (sum +  grid[x][y]) % k;</span><br><span class="line">        <span class="keyword">if</span> (dp[x][y][sum] != -<span class="number">1</span>) <span class="keyword">return</span> dp[x][y][sum];</span><br><span class="line">        <span class="keyword">if</span> (x == m - <span class="number">1</span> &amp;&amp; y == n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum % k == <span class="number">0</span>) <span class="keyword">return</span> dp[x][y][sum] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> dp[x][y][sum] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res1</span> <span class="operator">=</span> dfs(x + <span class="number">1</span>, y, sum);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res2</span> <span class="operator">=</span> dfs(x, y + <span class="number">1</span>, sum);</span><br><span class="line">        <span class="keyword">return</span> dp[x][y][sum] = (res1 + res2) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DP</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfPaths</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n][<span class="number">50</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][grid[<span class="number">0</span>][<span class="number">0</span>] % k] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">0</span>; z &lt; k; z++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j][z] = (dp[i][j][z] + dp[i - <span class="number">1</span>][j][((z - grid[i][j] % k) + k) % k]) % mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j][z] = (dp[i][j][z] + dp[i][j - <span class="number">1</span>][((z - grid[i][j] % k) + k) % k]) % mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;A&quot;&gt;&lt;a href=&quot;#A&quot; class=&quot;headerlink&quot; title=&quot;A&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/the-employee-that-worked-on-the-longest-task/&quot;&gt;A&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;思路：比赛时看到题目就是求最大的差值，然后直接想着排序，第一个就是答案。其实可以模拟。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://s1koy.github.io/categories/LeetCode/"/>
    
    
    <category term="动态规划" scheme="https://s1koy.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="二进制" scheme="https://s1koy.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2281. 巫师的总力量和</title>
    <link href="https://s1koy.github.io/2022/05/23/LeetCode-2281-%E5%B7%AB%E5%B8%88%E7%9A%84%E6%80%BB%E5%8A%9B%E9%87%8F%E5%92%8C/"/>
    <id>https://s1koy.github.io/2022/05/23/LeetCode-2281-%E5%B7%AB%E5%B8%88%E7%9A%84%E6%80%BB%E5%8A%9B%E9%87%8F%E5%92%8C/</id>
    <published>2022-05-23T05:55:47.000Z</published>
    <updated>2022-05-23T06:28:55.597Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>思路：看到题目第一眼想的是线段树维护区间最值，然后子数组是否可以通过区间部分合并呢，然后发现考虑的情况太少了，只能合并区间的首尾，不能维护所有的子区间，<script type="math/tex">GG</script>。 </p><span id="more"></span><p>正解：<a href="https://leetcode.cn/problems/sum-of-total-strength-of-wizards/solution/ji-suan-mei-ge-shu-zi-zuo-wei-zui-xiao-z-3jvr/">参考</a> 其实应该想到的，首先找以某个位置为最小值的左右最大范围，这里还要注意重复的问题，比如<script type="math/tex">\{1,3,1,2\}</script>  这里两个<script type="math/tex">1</script>都会求整个数组，为了不重复，我们往右边扩的时候一旦等于就直接停止，这样就不会重复了。单调栈处理即可。</p><p>然后求这个范围的所有子区间的和，然后乘以这个数即可。</p><p>那么某个子区间<script type="math/tex">[l,r]</script>的和可以通过前缀和<script type="math/tex">sum[i]=a[0]+a[1]+……+a[i]</script>搞一搞，即<script type="math/tex">sum[r]-sum[l-1]</script>。</p><p>假如遍历到<script type="math/tex">i</script>的位置，以它为最小值的左右范围为<script type="math/tex">[L,R]</script>，那个该区间的所有子区间的和应为：</p><script type="math/tex; mode=display">\sum_{l=L}^i\sum_{r=i}^Rsum[r]-sum[l-1]</script><p>由于<script type="math/tex">sum[r]</script>与<script type="math/tex">l</script>无关，<script type="math/tex">sum[l-1]</script>与<script type="math/tex">r</script>无关，所以上式可变为：</p><script type="math/tex; mode=display">\sum_{r=i}^R(i-L+1)sum[r]-\sum_{l=L}^i(R-i+1)sum[l-1]</script><p>可以再变为：</p><script type="math/tex; mode=display">(i-L+1)\sum_{r=i}^Rsum[r]-(R-i+1)\sum_{l=L-1}^{i-1}sum[l]</script><p>发现<script type="math/tex">\sum_{r=i}^Rsum[r]</script>即为前缀和的前缀和，所以再维护出前缀和的前缀和即可搞定此题。</p><p>最后就是取模问题，减法取模：<script type="math/tex">(a - b + mod) \% mod</script>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">    <span class="type">int</span>[] ss;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalStrength</span><span class="params">(<span class="type">int</span>[] strength)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> strength.length;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(right, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; strength[stack.peek()] &gt;= strength[i])</span><br><span class="line">                right[stack.pop()] = i;</span><br><span class="line">            left[i] = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> strength[<span class="number">0</span>];</span><br><span class="line">        ss = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        ss[<span class="number">0</span>] = strength[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            s = (s + strength[i]) % mod;</span><br><span class="line">            ss[i] = (ss[i - <span class="number">1</span>] + s) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left[i] + <span class="number">1</span>, r = right[i] - <span class="number">1</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lSum</span> <span class="operator">=</span> (<span class="type">long</span>) (i - l + <span class="number">1</span>) * fun(i - <span class="number">1</span>, r) % mod;</span><br><span class="line">            <span class="type">long</span> <span class="variable">rSum</span> <span class="operator">=</span> (<span class="type">long</span>) (r - i + <span class="number">1</span>) * fun(l - <span class="number">2</span>, i - <span class="number">1</span>) % mod;</span><br><span class="line">            ans = (ans + strength[i] * ((lSum - rSum + mod) % mod) % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; <span class="number">0</span>) <span class="keyword">return</span> ss[r];</span><br><span class="line">        <span class="keyword">return</span> ss[r] - ss[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;思路：看到题目第一眼想的是线段树维护区间最值，然后子数组是否可以通过区间部分合并呢，然后发现考虑的情况太少了，只能合并区间的首尾，不能维护所有的子区间，&lt;script type=&quot;math/tex&quot;&gt;GG&lt;/script&gt;。 &lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://s1koy.github.io/categories/LeetCode/"/>
    
    
    <category term="前缀和" scheme="https://s1koy.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2276. 统计区间中的整数数目</title>
    <link href="https://s1koy.github.io/2022/05/18/LeetCode-2276-%E7%BB%9F%E8%AE%A1%E5%8C%BA%E9%97%B4%E4%B8%AD%E7%9A%84%E6%95%B4%E6%95%B0%E6%95%B0%E7%9B%AE/"/>
    <id>https://s1koy.github.io/2022/05/18/LeetCode-2276-%E7%BB%9F%E8%AE%A1%E5%8C%BA%E9%97%B4%E4%B8%AD%E7%9A%84%E6%95%B4%E6%95%B0%E6%95%B0%E7%9B%AE/</id>
    <published>2022-05-18T15:20:32.000Z</published>
    <updated>2022-05-18T15:39:18.636Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="2276-统计区间中的整数数目"><a href="#2276-统计区间中的整数数目" class="headerlink" title="2276. 统计区间中的整数数目"></a><a href="https://leetcode.cn/problems/count-integers-in-intervals/">2276. 统计区间中的整数数目</a></h4><p>思路：区间赋值，区间查询，线段树。但是数据范围大的离谱，而且与之前不同的是，这道题是强制在线的，几年不写就忘了不断地新加 叫做 强制在线，不然赛中就过了。然后这道题可以动态开点，或者使用珂朵莉树，又重温了一遍，总结了模板，下次必拿下。</p><p>线段树就区间赋值，这里使用了<script type="math/tex">lazy</script>标记，复习了一遍，见博客园的三次方求和线段树。</p><p>珂朵莉树就是 将新加入区间<script type="math/tex">[left,right]</script> 所能覆盖或相交的区间合并成一个新的区间，按右端点排序，找到所有的<strong>右端点比新加入区间左端点大</strong>且<strong>左端点小于新加入区间的右端点</strong>的区间，将其合并（即删除），然后不断扩张<script type="math/tex">left</script>和<script type="math/tex">right</script>，最后的<script type="math/tex">[left,right]</script>即为合并后的区间，期间可以维护想要的信息。</p><p>动态开点线段树 <code>代码一</code> </p><p>珂朵莉树 <code>代码二</code></p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CountIntervals</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> SegmentTree02 t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CountIntervals</span><span class="params">()</span> &#123;</span><br><span class="line">        t = <span class="keyword">new</span> <span class="title class_">SegmentTree02</span>(<span class="number">1</span>, <span class="number">1000000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        t.modify(t.root, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t.root.sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SegmentTree02</span> &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">            <span class="type">int</span> l,r,sum,lazy;</span><br><span class="line">            Node lchild, rchild;</span><br><span class="line">            Node(<span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">                <span class="built_in">this</span>.l = l;</span><br><span class="line">                <span class="built_in">this</span>.r = r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Node root;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SegmentTree02</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">Node</span>(l, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(Node p)</span> &#123;</span><br><span class="line">            p.sum = p.lchild.sum + p.rchild.sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushDown</span><span class="params">(Node p)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.lazy == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            p.lchild.sum = (p.lchild.r - p.lchild.l + <span class="number">1</span>) * p.lazy;</span><br><span class="line">            p.rchild.sum = (p.rchild.r - p.rchild.l + <span class="number">1</span>) * p.lazy;</span><br><span class="line">            p.lchild.lazy = p.rchild.lazy = p.lazy;</span><br><span class="line">            p.lazy = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modify</span><span class="params">(Node p, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.l &gt;= L &amp;&amp; p.r &lt;= R) &#123;</span><br><span class="line">                p.sum = p.r - p.l + <span class="number">1</span>;</span><br><span class="line">                p.lazy = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (p.r - p.l) / <span class="number">2</span> + p.l;</span><br><span class="line">            <span class="keyword">if</span> (p.lchild == <span class="literal">null</span>) p.lchild = <span class="keyword">new</span> <span class="title class_">Node</span>(p.l, mid);</span><br><span class="line">            <span class="keyword">if</span> (p.rchild == <span class="literal">null</span>) p.rchild = <span class="keyword">new</span> <span class="title class_">Node</span>(mid + <span class="number">1</span>, p.r);</span><br><span class="line">            pushDown(p);</span><br><span class="line">            <span class="keyword">if</span> (L &lt;= mid) modify(p.lchild, L, R);</span><br><span class="line">            <span class="keyword">if</span> (R &gt; mid) modify(p.rchild, L, R);</span><br><span class="line">            pushUp(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(Node p, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.l &gt;= L &amp;&amp; p.r &lt;= R) &#123;</span><br><span class="line">                <span class="keyword">return</span> p.sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (p.r - p.l) / <span class="number">2</span> + p.l;</span><br><span class="line">            <span class="keyword">if</span> (p.lchild == <span class="literal">null</span>) p.lchild = <span class="keyword">new</span> <span class="title class_">Node</span>(p.l, mid);</span><br><span class="line">            <span class="keyword">if</span> (p.rchild == <span class="literal">null</span>) p.rchild = <span class="keyword">new</span> <span class="title class_">Node</span>(mid + <span class="number">1</span>, p.r);</span><br><span class="line">            pushDown(p);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (L &lt;= mid) ans += query(p.lchild, p.l, mid);</span><br><span class="line">            <span class="keyword">if</span> (R &gt; mid) ans += query(p.rchild, mid + <span class="number">1</span>, p.r);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CountIntervals</span> &#123;</span><br><span class="line"></span><br><span class="line">    TreeMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CountIntervals</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        Map.Entry&lt;Integer, Integer&gt; entry = map.ceilingEntry(left);</span><br><span class="line">        <span class="keyword">while</span> (entry != <span class="literal">null</span> &amp;&amp; entry.getValue() &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> entry.getValue(), r = entry.getKey();</span><br><span class="line">            left = Math.min(left, l);</span><br><span class="line">            right = Math.max(right, r);</span><br><span class="line">            sum -= r - l + <span class="number">1</span>;</span><br><span class="line">            map.remove(r);</span><br><span class="line">            entry = map.ceilingEntry(left);</span><br><span class="line">        &#125;</span><br><span class="line">        sum += right - left + <span class="number">1</span>;</span><br><span class="line">        map.put(right, left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CountIntervals object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CountIntervals obj = new CountIntervals();</span></span><br><span class="line"><span class="comment"> * obj.add(left,right);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.count();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;2276-统计区间中的整数数目&quot;&gt;&lt;a href=&quot;#2276-统计区间中的整数数目&quot; class=&quot;headerlink&quot; title=&quot;2276. 统计区间中的整数数目&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/count-integers-in-intervals/&quot;&gt;2276. 统计区间中的整数数目&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;思路：区间赋值，区间查询，线段树。但是数据范围大的离谱，而且与之前不同的是，这道题是强制在线的，几年不写就忘了不断地新加 叫做 强制在线，不然赛中就过了。然后这道题可以动态开点，或者使用珂朵莉树，又重温了一遍，总结了模板，下次必拿下。&lt;/p&gt;
&lt;p&gt;线段树就区间赋值，这里使用了&lt;script type=&quot;math/tex&quot;&gt;lazy&lt;/script&gt;标记，复习了一遍，见博客园的三次方求和线段树。&lt;/p&gt;
&lt;p&gt;珂朵莉树就是 将新加入区间&lt;script type=&quot;math/tex&quot;&gt;[left,right]&lt;/script&gt; 所能覆盖或相交的区间合并成一个新的区间，按右端点排序，找到所有的&lt;strong&gt;右端点比新加入区间左端点大&lt;/strong&gt;且&lt;strong&gt;左端点小于新加入区间的右端点&lt;/strong&gt;的区间，将其合并（即删除），然后不断扩张&lt;script type=&quot;math/tex&quot;&gt;left&lt;/script&gt;和&lt;script type=&quot;math/tex&quot;&gt;right&lt;/script&gt;，最后的&lt;script type=&quot;math/tex&quot;&gt;[left,right]&lt;/script&gt;即为合并后的区间，期间可以维护想要的信息。&lt;/p&gt;
&lt;p&gt;动态开点线段树 &lt;code&gt;代码一&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;珂朵莉树 &lt;code&gt;代码二&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>LeetCode 668. 乘法表中第k小的数</title>
    <link href="https://s1koy.github.io/2022/05/18/LeetCode-668-%E4%B9%98%E6%B3%95%E8%A1%A8%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
    <id>https://s1koy.github.io/2022/05/18/LeetCode-668-%E4%B9%98%E6%B3%95%E8%A1%A8%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E6%95%B0/</id>
    <published>2022-05-18T14:41:47.000Z</published>
    <updated>2022-05-18T15:39:47.597Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="668-乘法表中第k小的数"><a href="#668-乘法表中第k小的数" class="headerlink" title="668. 乘法表中第k小的数"></a><a href="https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/">668. 乘法表中第k小的数</a></h4><p>思路：第一眼第<script type="math/tex">k</script>大就是直接就说主席树，然后发现数据范围很大，然后在考虑看成树的样子，虽然不可行，不过这样是计算正解的的一种方法，最后就想通过筛数来搞，发现不可能，直接看题解吧……</p><p>正解：数据范围太大，直接二分答案，设第<script type="math/tex">k</script>大的数为<script type="math/tex">x</script>，则$\le x$的数字个数不超过<script type="math/tex">k</script>个，因为每一行的数都是该行第一个数的递增倍数，所以当前行<script type="math/tex">\le x</script>的个数为<script type="math/tex">\lfloor \frac{x}{i} \rfloor</script>，差点以为自己的二分有问题，发现求得就是左边界，搞错了，可能是饿的了。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthNumber</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>, r = m * n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (r - l) / <span class="number">2</span> + l;</span><br><span class="line">            <span class="keyword">if</span> (check(m, n, mid, k)) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> x, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> x / n * n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x / n + <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            cnt += x / i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &gt;= k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;668-乘法表中第k小的数&quot;&gt;&lt;a href=&quot;#668-乘法表中第k小的数&quot; class=&quot;headerlink&quot; title=&quot;668. 乘法表中第k小的数&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/&quot;&gt;668. 乘法表中第k小的数&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;思路：第一眼第&lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;大就是直接就说主席树，然后发现数据范围很大，然后在考虑看成树的样子，虽然不可行，不过这样是计算正解的的一种方法，最后就想通过筛数来搞，发现不可能，直接看题解吧……&lt;/p&gt;
&lt;p&gt;正解：数据范围太大，直接二分答案，设第&lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;大的数为&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;，则$\le x$的数字个数不超过&lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;个，因为每一行的数都是该行第一个数的递增倍数，所以当前行&lt;script type=&quot;math/tex&quot;&gt;\le x&lt;/script&gt;的个数为&lt;script type=&quot;math/tex&quot;&gt;\lfloor \frac{x}{i} \rfloor&lt;/script&gt;，差点以为自己的二分有问题，发现求得就是左边界，搞错了，可能是饿的了。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://s1koy.github.io/categories/LeetCode/"/>
    
    
    <category term="二分" scheme="https://s1koy.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 22. 括号生成</title>
    <link href="https://s1koy.github.io/2022/05/13/LeetCode-22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <id>https://s1koy.github.io/2022/05/13/LeetCode-22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</id>
    <published>2022-05-13T07:06:43.000Z</published>
    <updated>2022-10-21T06:16:20.362Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>数据范围最多<script type="math/tex">16</script>个位置，每个位置两种选择，直接<script type="math/tex">DFS</script>搜索即可，这里将<strong>（</strong> 看成<script type="math/tex">1</script> , <strong>)</strong> 看成<script type="math/tex">-1</script> ，然后就可以剪枝，不需要最后再检查序列是否合法。<code>代码一</code></p><p>以上方法，也可以使用遍历的方式来模拟出来，每次只保留合法的序列即可，同样使用上述规则来维护合法序列。<code>代码二</code></p><p>动态规划：考虑已知<script type="math/tex">n-1</script>对括号的所有合法序列，那么对于第<script type="math/tex">n</script>对括号来说，相当于<strong>(A)B</strong>，即将<script type="math/tex">n-1</script>对括号分成<strong>A和B</strong>，其中<script type="math/tex">A+B=n-1</script>，所以枚举<strong>A和B</strong>的所有可能即可，不会重复。</p><p>定义：<script type="math/tex">dp[i]</script>表示括号对数为<script type="math/tex">i</script>的所有合法序列。</p><p>转移方程：<script type="math/tex">\sum_{i=2}^n\sum_{j=0}^{i-1} dp[i]='(' + dp[j] + ')' + dp[i - 1 -j]</script>，<strong>注意：</strong>这里的<script type="math/tex">dp</script>要枚举其所有序列</p><p>答案为<script type="math/tex">dp[n]</script>，<code>代码三</code></p><span id="more"></span><ul><li>n = 0 : “”</li><li>n = 1: “()”</li><li>n = 2:  (0)1，(1)0  即 “()()”，”(())”</li><li>n = 3: (0)2，(1)1，(2)0 即 “()()()”，”()(())”，”(())()”，”(()())”，”((()))”  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        sb.append(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">0</span> || sum &gt; n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="number">2</span> * n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">1</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">                ans.add(sb.toString());</span><br><span class="line">                sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        dfs(idx + <span class="number">1</span>, sum + <span class="number">1</span>);</span><br><span class="line">        sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        sb.append(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        dfs(idx + <span class="number">1</span>, sum - <span class="number">1</span>);</span><br><span class="line">        sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        map.put(<span class="string">&quot;(&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">            Map&lt;String, Integer&gt; change = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">                <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">2</span> * n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (val == <span class="number">1</span>) ans.add(s + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (val &lt; <span class="number">0</span> || val &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">                    change.put(s + <span class="string">&quot;(&quot;</span>, val + <span class="number">1</span>);</span><br><span class="line">                    change.put(s + <span class="string">&quot;)&quot;</span>, val - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            map = change;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码三</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;String&gt;[] dp = <span class="keyword">new</span> <span class="title class_">List</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) dp[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dp[<span class="number">0</span>].add(<span class="string">&quot;&quot;</span>); dp[<span class="number">1</span>].add(<span class="string">&quot;()&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                List&lt;String&gt; list1 = dp[j];</span><br><span class="line">                List&lt;String&gt; list2 = dp[i - j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (String k1 : list1) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String k2 : list2) &#123;</span><br><span class="line">                        dp[i].add(<span class="string">&quot;(&quot;</span> + k1 + <span class="string">&quot;)&quot;</span> + k2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;数据范围最多&lt;script type=&quot;math/tex&quot;&gt;16&lt;/script&gt;个位置，每个位置两种选择，直接&lt;script type=&quot;math/tex&quot;&gt;DFS&lt;/script&gt;搜索即可，这里将&lt;strong&gt;（&lt;/strong&gt; 看成&lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt; , &lt;strong&gt;)&lt;/strong&gt; 看成&lt;script type=&quot;math/tex&quot;&gt;-1&lt;/script&gt; ，然后就可以剪枝，不需要最后再检查序列是否合法。&lt;code&gt;代码一&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以上方法，也可以使用遍历的方式来模拟出来，每次只保留合法的序列即可，同样使用上述规则来维护合法序列。&lt;code&gt;代码二&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;动态规划：考虑已知&lt;script type=&quot;math/tex&quot;&gt;n-1&lt;/script&gt;对括号的所有合法序列，那么对于第&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;对括号来说，相当于&lt;strong&gt;(A)B&lt;/strong&gt;，即将&lt;script type=&quot;math/tex&quot;&gt;n-1&lt;/script&gt;对括号分成&lt;strong&gt;A和B&lt;/strong&gt;，其中&lt;script type=&quot;math/tex&quot;&gt;A+B=n-1&lt;/script&gt;，所以枚举&lt;strong&gt;A和B&lt;/strong&gt;的所有可能即可，不会重复。&lt;/p&gt;
&lt;p&gt;定义：&lt;script type=&quot;math/tex&quot;&gt;dp[i]&lt;/script&gt;表示括号对数为&lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;的所有合法序列。&lt;/p&gt;
&lt;p&gt;转移方程：&lt;script type=&quot;math/tex&quot;&gt;\sum_{i=2}^n\sum_{j=0}^{i-1} dp[i]=&#39;(&#39; + dp[j] + &#39;)&#39; + dp[i - 1 -j]&lt;/script&gt;，&lt;strong&gt;注意：&lt;/strong&gt;这里的&lt;script type=&quot;math/tex&quot;&gt;dp&lt;/script&gt;要枚举其所有序列&lt;/p&gt;
&lt;p&gt;答案为&lt;script type=&quot;math/tex&quot;&gt;dp[n]&lt;/script&gt;，&lt;code&gt;代码三&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://s1koy.github.io/categories/LeetCode/"/>
    
    
    <category term="动态规划" scheme="https://s1koy.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="DFS" scheme="https://s1koy.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 19. 删除链表的倒数第 N 个结点</title>
    <link href="https://s1koy.github.io/2022/05/11/LeetCode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>https://s1koy.github.io/2022/05/11/LeetCode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/</id>
    <published>2022-05-11T14:53:26.000Z</published>
    <updated>2022-05-13T07:08:33.727Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h4><p>思路：遍历一遍拿到长度，然后删除倒数第<script type="math/tex">n</script>个，判断是否是边界即可。<code>代码一</code></p><p>双指针做法：首先让<script type="math/tex">r</script>指针先走<script type="math/tex">n</script>个节点，然后<script type="math/tex">l</script>和<script type="math/tex">r</script>指针一起移动，直到<script type="math/tex">r</script>走到末尾，然后删除<script type="math/tex">r.next</script>。这里可以设置假节点，便于编码。<code>代码二</code></p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码一</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// public static class ListNode &#123;</span></span><br><span class="line"><span class="comment">//     int val;</span></span><br><span class="line"><span class="comment">//     ListNode next;</span></span><br><span class="line"><span class="comment">//     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment">//     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment">//     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;ListNode&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">ListNode</span>(p.val, p.next));</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> list.size();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            list.get(i).next = list.get(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == len) &#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            list.remove(len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                list.get(len - <span class="number">2</span>).next = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">preNode</span> <span class="operator">=</span> list.get(len - n - <span class="number">1</span>);</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">sufNode</span> <span class="operator">=</span> list.get(len - n + <span class="number">1</span>);</span><br><span class="line">            preNode.next = sufNode;</span><br><span class="line">            <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cnt++ &lt; n) &#123;</span><br><span class="line">            r = r.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="keyword">while</span> (r.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            r = r.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next = p.next.next;</span><br><span class="line">        <span class="keyword">return</span> l.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;19-删除链表的倒数第-N-个结点&quot;&gt;&lt;a href=&quot;#19-删除链表的倒数第-N-个结点&quot; class=&quot;headerlink&quot; title=&quot;19. 删除链表的倒数第 N 个结点&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/remove-nth-node-from-end-of-list/&quot;&gt;19. 删除链表的倒数第 N 个结点&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;思路：遍历一遍拿到长度，然后删除倒数第&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;个，判断是否是边界即可。&lt;code&gt;代码一&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;双指针做法：首先让&lt;script type=&quot;math/tex&quot;&gt;r&lt;/script&gt;指针先走&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;个节点，然后&lt;script type=&quot;math/tex&quot;&gt;l&lt;/script&gt;和&lt;script type=&quot;math/tex&quot;&gt;r&lt;/script&gt;指针一起移动，直到&lt;script type=&quot;math/tex&quot;&gt;r&lt;/script&gt;走到末尾，然后删除&lt;script type=&quot;math/tex&quot;&gt;r.next&lt;/script&gt;。这里可以设置假节点，便于编码。&lt;code&gt;代码二&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://s1koy.github.io/categories/LeetCode/"/>
    
    
    <category term="双指针" scheme="https://s1koy.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 954. 二倍数对数组</title>
    <link href="https://s1koy.github.io/2022/04/05/LeetCode-954-%E4%BA%8C%E5%80%8D%E6%95%B0%E5%AF%B9%E6%95%B0%E7%BB%84/"/>
    <id>https://s1koy.github.io/2022/04/05/LeetCode-954-%E4%BA%8C%E5%80%8D%E6%95%B0%E5%AF%B9%E6%95%B0%E7%BB%84/</id>
    <published>2022-04-05T14:26:46.000Z</published>
    <updated>2022-04-07T02:20:09.962Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>思路：一开始想的是肯定要排序，从小到大，然后遍历每个数字的一半在不在哈希表里，哈希表维护每个数出现的次数，然后每次能够找到自己的一半的话就对应相消，注意的<script type="math/tex">0</script>时候，能够相消的条件是当前<script type="math/tex">0</script>的个数<script type="math/tex">cnt</script>要满足：<script type="math/tex">cnt>1</script>，因为<script type="math/tex">0</script>的一半是它自身，其他数字就存在即可。这样如果能够成对的话，成功相消的次数应该是数组长度的一半。<code>代码一</code></p><span id="more"></span><p>然后看了官方题解思路：将<script type="math/tex">0</script>进行特判，因为必须是成对的。然后排序不是简单的从小到大排序，是按照绝对值的大小排序，因为设<script type="math/tex">x</script>为绝对值最小的数，没有比它更小的数，所以只能找成对的<script type="math/tex">2*x</script>进行配对，然后将<script type="math/tex">2*x</script>的个数减掉相应值即可，如果出现不够减，就不能满足成对的要求。<code>代码二</code></p><p>然后看了宫水三叶的思路：以上思路都是要进行排序，复杂度主要是排序带来的，这里比较巧妙的是可以利用<script type="math/tex">x</script>只可能与<script type="math/tex">\frac{x}2</script>或者<script type="math/tex">2*x</script>组成对数来建图，因为如果排除<script type="math/tex">0</script>的可能，就不会存在环路，因为可以跑拓扑序来验证是否可行。</p><p>首先对数组进行数量统计，然后去重（跳过<script type="math/tex">0</script>)，因为会产生自环。然后对出现的值<script type="math/tex">x</script>进行讨论：</p><ul><li><script type="math/tex">x</script>为奇数：只能作为数对中绝对值较小的数字，即<script type="math/tex">x</script>的入度为<script type="math/tex">0</script>，加入队列。</li><li><script type="math/tex">x</script>为偶数：首先入度<script type="math/tex">in[x]=cnt[\frac{x}2]</script>，当<script type="math/tex">in[x]=0</script>，说明只能作为数对中绝对值较小的数字，入队。</li></ul><p>假设当前出队值为<script type="math/tex">t</script>，要消耗<script type="math/tex">cnt[t]</script>个<script type="math/tex">2*t</script>与其构成数对，则<script type="math/tex">cnt[2*t]-=cnt[t]</script>，同时<script type="math/tex">in[2*t]-=cnt[t]</script>，如果<script type="math/tex">in[2*t]=0</script>且<script type="math/tex">cnt[2*t]>0</script>，入队，由于减少了<script type="math/tex">2*t</script>的数量，要同时更新<script type="math/tex">in[4*t]</script>，当<script type="math/tex">in[4*t]=0</script>且<script type="math/tex">cnt[4*t]>0</script>，需要将<script type="math/tex">4*t</script>入队。<code>代码三</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canReorderDoubled</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(arr[i])) &#123;</span><br><span class="line">                map.put(arr[i], map.get(arr[i]) + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(arr[i], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((arr[i] &amp; <span class="number">1</span>) == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (map.get(arr[i]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(arr[i] / <span class="number">2</span>)) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> arr[i] == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (map.get(arr[i] / <span class="number">2</span>) &gt; limit) &#123;</span><br><span class="line">                        map.put((arr[i] / <span class="number">2</span>), map.get(arr[i] / <span class="number">2</span>) - <span class="number">1</span>);</span><br><span class="line">                        map.put(arr[i], map.get(arr[i]) - <span class="number">1</span>);</span><br><span class="line">                        ans++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len / <span class="number">2</span> != ans) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canReorderDoubled</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            cnt.put(arr[i], cnt.getOrDefault(arr[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">zero</span> <span class="operator">=</span> cnt.getOrDefault(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (zero % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : cnt.keySet()) &#123;</span><br><span class="line">            list.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(list, (a, b) -&gt; Math.abs(a) - Math.abs(b));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> cnt.get(val);</span><br><span class="line">            <span class="keyword">if</span> (cnt.getOrDefault(<span class="number">2</span> * val, <span class="number">0</span>) &lt; num) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            cnt.put(<span class="number">2</span> * val, cnt.getOrDefault(<span class="number">2</span> * val, <span class="number">0</span>) - num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码三</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canReorderDoubled</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; in = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            cnt.put(arr[i], cnt.getOrDefault(arr[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">zero</span> <span class="operator">=</span> cnt.getOrDefault(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (zero % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Deque&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : cnt.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (x % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> cnt.getOrDefault(x / <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">                in.put(x, num);</span><br><span class="line">                <span class="keyword">if</span> (num == <span class="number">0</span>) queue.add(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> cnt.get(x);</span><br><span class="line">            <span class="keyword">if</span> (cnt.getOrDefault(<span class="number">2</span> * x, <span class="number">0</span>) &lt; num) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            cnt.put(<span class="number">2</span> * x, cnt.get(<span class="number">2</span> * x) - num);</span><br><span class="line">            in.put(<span class="number">2</span> * x, in.get(<span class="number">2</span> * x) - num);</span><br><span class="line">            <span class="keyword">if</span> (in.get(<span class="number">2</span> * x) == <span class="number">0</span> &amp;&amp; cnt.get(<span class="number">2</span> * x) &gt; <span class="number">0</span>) queue.add(<span class="number">2</span> * x);</span><br><span class="line">            in.put(<span class="number">4</span> * x, in.getOrDefault(<span class="number">4</span> * x, <span class="number">0</span>) - num);</span><br><span class="line">            <span class="keyword">if</span> (in.getOrDefault(<span class="number">4</span> * x, <span class="number">0</span>) == <span class="number">0</span> &amp;&amp; cnt.getOrDefault(<span class="number">4</span> * x, <span class="number">0</span>) &gt; <span class="number">0</span>) queue.add(<span class="number">4</span> * x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;思路：一开始想的是肯定要排序，从小到大，然后遍历每个数字的一半在不在哈希表里，哈希表维护每个数出现的次数，然后每次能够找到自己的一半的话就对应相消，注意的&lt;script type=&quot;math/tex&quot;&gt;0&lt;/script&gt;时候，能够相消的条件是当前&lt;script type=&quot;math/tex&quot;&gt;0&lt;/script&gt;的个数&lt;script type=&quot;math/tex&quot;&gt;cnt&lt;/script&gt;要满足：&lt;script type=&quot;math/tex&quot;&gt;cnt&gt;1&lt;/script&gt;，因为&lt;script type=&quot;math/tex&quot;&gt;0&lt;/script&gt;的一半是它自身，其他数字就存在即可。这样如果能够成对的话，成功相消的次数应该是数组长度的一半。&lt;code&gt;代码一&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://s1koy.github.io/categories/LeetCode/"/>
    
    
    <category term="哈希表" scheme="https://s1koy.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="排序" scheme="https://s1koy.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="拓扑" scheme="https://s1koy.github.io/tags/%E6%8B%93%E6%89%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 693. 交替位二进制数</title>
    <link href="https://s1koy.github.io/2022/03/28/LeetCode-693-%E4%BA%A4%E6%9B%BF%E4%BD%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/"/>
    <id>https://s1koy.github.io/2022/03/28/LeetCode-693-%E4%BA%A4%E6%9B%BF%E4%BD%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/</id>
    <published>2022-03-28T12:19:21.000Z</published>
    <updated>2022-04-07T02:28:41.359Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="693-交替位二进制数"><a href="#693-交替位二进制数" class="headerlink" title="693. 交替位二进制数"></a><a href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/">693. 交替位二进制数</a></h4><p>思路一：直接模拟取余，然后判断是否存在连续的<script type="math/tex">0</script>或<script type="math/tex">1</script>。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasAlternatingBits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span> == mod) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            mod = n % <span class="number">2</span>;</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：考虑二进制。一开始的思路是直接搞出来最大的奇<script type="math/tex">10101010……1</script>串和偶<script type="math/tex">10101010……0</script>串，然后再与<script type="math/tex">n</script>直接进行操作不过好像有点麻烦，考虑了多种方式都无法实现，然后能搞出来的方法就有点麻烦了。索性看了题解：首先<script type="math/tex">n</script>右移一位，然后再与本身异或操作，如果是交替的话，就是全<script type="math/tex">1</script>串了，然后只需要判断是否全<script type="math/tex">1</script>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasAlternatingBits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> n ^ (n &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((x &amp; (x + <span class="number">1</span>)) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;693-交替位二进制数&quot;&gt;&lt;a href=&quot;#693-交替位二进制数&quot; class=&quot;headerlink&quot; title=&quot;693. 交替位二进制数&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-number-with-alternating-bits/&quot;&gt;693. 交替位二进制数&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;思路一：直接模拟取余，然后判断是否存在连续的&lt;script type=&quot;math/tex&quot;&gt;0&lt;/script&gt;或&lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://s1koy.github.io/categories/LeetCode/"/>
    
    
    <category term="二进制" scheme="https://s1koy.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2028. 找出缺失的观测数据</title>
    <link href="https://s1koy.github.io/2022/03/27/LeetCode-2028-%E6%89%BE%E5%87%BA%E7%BC%BA%E5%A4%B1%E7%9A%84%E8%A7%82%E6%B5%8B%E6%95%B0%E6%8D%AE/"/>
    <id>https://s1koy.github.io/2022/03/27/LeetCode-2028-%E6%89%BE%E5%87%BA%E7%BC%BA%E5%A4%B1%E7%9A%84%E8%A7%82%E6%B5%8B%E6%95%B0%E6%8D%AE/</id>
    <published>2022-03-27T15:40:30.000Z</published>
    <updated>2022-04-07T02:30:27.800Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="2028-找出缺失的观测数据"><a href="#2028-找出缺失的观测数据" class="headerlink" title="2028. 找出缺失的观测数据"></a><a href="https://leetcode-cn.com/problems/find-missing-observations/">2028. 找出缺失的观测数据</a></h4><p>思路：首先统计已有的总和，然后算出剩余需要的<script type="math/tex">res</script>，如果<script type="math/tex">\ res<n || res>6*n\</script>就不可能了，然后看是否<script type="math/tex">res</script>能够均分到<script type="math/tex">n</script>个位置，如果能够最好，不能的话肯定有剩余<script type="math/tex">mod</script>，而且<script type="math/tex">mod</script>肯定小于<script type="math/tex">n</script>，也就是把余数每个位置放一个的策略是正确的。可以对余数再遍历一遍，也可以在放的时候直接搞定。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] missingRolls(<span class="type">int</span>[] rolls, <span class="type">int</span> mean, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x: rolls) &#123;</span><br><span class="line">            sum += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> rolls.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> (n + m) * mean - sum;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; n || res &gt; n * <span class="number">6</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans[i] = res % n == <span class="number">0</span> ? res / n : res-- / n + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;2028-找出缺失的观测数据&quot;&gt;&lt;a href=&quot;#2028-找出缺失的观测数据&quot; class=&quot;headerlink&quot; title=&quot;2028. 找出缺失的观测数据&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-missing-observations/&quot;&gt;2028. 找出缺失的观测数据&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;思路：首先统计已有的总和，然后算出剩余需要的&lt;script type=&quot;math/tex&quot;&gt;res&lt;/script&gt;，如果&lt;script type=&quot;math/tex&quot;&gt;\ res&lt;n || res&gt;6*n\&lt;/script&gt;就不可能了，然后看是否&lt;script type=&quot;math/tex&quot;&gt;res&lt;/script&gt;能够均分到&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;个位置，如果能够最好，不能的话肯定有剩余&lt;script type=&quot;math/tex&quot;&gt;mod&lt;/script&gt;，而且&lt;script type=&quot;math/tex&quot;&gt;mod&lt;/script&gt;肯定小于&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;，也就是把余数每个位置放一个的策略是正确的。可以对余数再遍历一遍，也可以在放的时候直接搞定。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://s1koy.github.io/categories/LeetCode/"/>
    
    
    <category term="构造" scheme="https://s1koy.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
</feed>
